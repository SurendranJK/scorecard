/**
 * Compute Stack Ranks per Period based on targets met and write back to the "scores" sheet.
 * - Looks for a sheet named "scores" (case-sensitive).
 * - If a sheet named "targets" exists, uses that row matching Period (YYYY-MM).
 * - Otherwise uses default target values defined below.
 *
 * New columns written in "scores":
 *   TargetsMet  (integer)
 *   ScorePercent (0-100 numeric)
 *   StackRank   (1 = best for that Period)
 *
 * Author: generated for you
 */

function computeStackRanks() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const scoresSheet = ss.getSheetByName('scores');
  if (!scoresSheet) {
    SpreadsheetApp.getUi().alert('No sheet named "scores" found. Rename your data tab to "scores".');
    return;
  }

  // Try to fetch targets sheet (optional)
  const targetsSheet = ss.getSheetByName('targets');

  // Default targets (fallback if no targets sheet or row for period)
  const DEFAULT_TARGETS = {
    // fractions for percent-like: store as decimal (0.92 = 92%)
    "100% DA": 0.92,
    "TTR Hours(Official)": 30,
    "PPMD": 1.13,
    "ECASE SLA_M2M": 0.97,
    "ECASE SLA_HG": 0.95,
    "Onsite Response Met%": 0.90,
    "Overall SLA%": 0.0 // optional - if you want set a target for Overall SLA put value here as decimal
  };

  // Helper: case-insensitive find column name among headers
  function findColName(headers, pattern) {
    const re = new RegExp(pattern, 'i');
    for (const h of headers) {
      if (h && re.test(h.toString())) return h;
    }
    return null;
  }

  // Read scores sheet header + data
  const scoresRange = scoresSheet.getDataRange();
  const scoresValues = scoresRange.getValues(); // 2D array
  if (scoresValues.length < 2) {
    SpreadsheetApp.getUi().alert('scores sheet has no data rows.');
    return;
  }
  let headers = scoresValues[0].map(h => (h || '').toString().trim());

  // Ensure we have a Period column in the scores sheet
  const periodHeader = headers.find(h => /period/i.test(h));
  if (!periodHeader) {
    SpreadsheetApp.getUi().alert('scores sheet must contain a Period column (header containing "Period").');
    return;
  }

  // Identify key columns (flexible matching)
  const empIdHeader = headers.find(h => /emp|id/i.test(h)) || headers[0];
  const nameHeader = headers.find(h => /engineer|name/i.test(h)) || null;
  const onsiteHeader = headers.find(h => /onsite/i.test(h)) || null;
  const overallHeader = headers.find(h => /overall.*sla|overall sla|overall/i.test(h)) || null;
  const totalClosedHeader = headers.find(h => /total.*closed|total.*volume|total closed volume/i.test(h)) || null;
  const ttrHeader = headers.find(h => /ttr|hours/i.test(h)) || null;
  const daHeader = headers.find(h => /100%.*da|100% DA|100%DA|100 percent da/i.test(h)) || headers.find(h => /100.*da/i) || null;
  const ppmdHeader = headers.find(h => /ppmd/i.test(h)) || null;
  const ppmcHeader = headers.find(h => /ppmc/i.test(h)) || null;
  const ecaseMHeader = headers.find(h => /ecase.*m2m|e.?case.*m/i.test(h)) || headers.find(h => /ECASE SLA_M2M/i) || null;
  const ecaseHHeader = headers.find(h => /ecase.*hg|e.?case.*h/i.test(h)) || headers.find(h => /ECASE SLA_HG/i) || null;

  // Determine where to write result columns (append if not exists)
  let targetsMetCol = headers.find(h => /^TargetsMet$/i.test(h));
  let scorePercentCol = headers.find(h => /^ScorePercent$/i.test(h));
  let stackRankCol = headers.find(h => /^StackRank$/i.test(h));

  let writeStartCol = headers.length + 1;
  if (!targetsMetCol) { targetsMetCol = 'TargetsMet'; headers.push(targetsMetCol); }
  if (!scorePercentCol) { scorePercentCol = 'ScorePercent'; headers.push(scorePercentCol); }
  if (!stackRankCol) { stackRankCol = 'StackRank'; headers.push(stackRankCol); }

  // If we added any headers, write them back to sheet header row
  scoresSheet.getRange(1, 1, 1, headers.length).setValues([headers]);

  // Build a map of targets per period if targets sheet exists
  const targetsByPeriod = {};
  if (targetsSheet) {
    const tRange = targetsSheet.getDataRange();
    const tVals = tRange.getValues();
    if (tVals.length >= 2) {
      const tHeaders = tVals[0].map(h => (h || '').toString().trim());
      const periodIdx = tHeaders.findIndex(h => /period/i.test(h));
      for (let r = 1; r < tVals.length; r++) {
        const row = tVals[r];
        const periodVal = (row[periodIdx] || '').toString().trim();
        if (!periodVal) continue;
        const obj = {};
        tHeaders.forEach((h,i) => {
          if (!h) return;
          obj[h] = row[i];
        });
        targetsByPeriod[periodVal] = obj;
      }
    }
  }

  // Helper to parse numeric / percent values
  function parseNumericCell(v) {
    if (v === null || v === undefined || v === '') return null;
    const s = String(v).trim();
    // percent string
    if (s.indexOf('%') !== -1) {
      const n = parseFloat(s.replace('%','').replace(/,/g,''));
      return isNaN(n) ? null : n/100;
    }
    const n = parseFloat(s.replace(/,/g,''));
    if (isNaN(n)) return null;
    if (n > 0 && n <= 1) return n; // fraction form
    return n;
  }

  // Collect rows grouped by period for ranking
  const rowsByPeriod = {}; // { period: [ {rowIndex, rowObj, targetsMet, scorePercent, totalClosed} ] }
  const headerIndex = {}; headers.forEach((h,i) => headerIndex[h] = i); // map header->col-index

  // iterate data rows
  for (let r = 1; r < scoresValues.length; r++) {
    const row = scoresValues[r];
    const rowObj = {};
    headers.forEach((h, idx) => {
      // For existing data columns (original columns) take from row; appended columns may be undefined
      rowObj[h] = (row[idx] !== undefined) ? row[idx] : '';
    });
    // Obtain the Period value from original data (use header discovery)
    const originalPeriodHeader = scoresValues[0].find(h => /period/i.test(h)) || 'Period';
    const periodVal = (row[ headers.indexOf(originalPeriodHeader) ] || '').toString().trim();
    if (!periodVal) continue;

    // Get the targets for this period: from targetsByPeriod if present, else DEFAULT_TARGETS
    const targetObj = targetsByPeriod[periodVal] || null;

    // Build target lookup for each metric using either targetObj or defaults
    const getTarget = (metricKeys, defaultKey) => {
      if (targetObj) {
        // find matching key in targetObj case-insensitive
        const found = Object.keys(targetObj).find(k => {
          return metricKeys.some(pk => String(k).trim().toLowerCase() === String(pk).trim().toLowerCase());
        });
        if (found) return parseNumericCell(targetObj[found]);
      }
      // fallback default
      return DEFAULT_TARGETS[defaultKey] !== undefined ? DEFAULT_TARGETS[defaultKey] : null;
    };

    const targetsToCheck = [
      {label: 'Onsite Response Met%', target: getTarget(['Onsite Response Met%', 'Onsite Response Met'], 'Onsite Response Met%'), value: parseNumericCell(row[ headers.indexOf(onsiteHeader) ]) , higherIsBetter: true},
      {label: 'Overall SLA%', target: getTarget(['Overall SLA%','Overall SLA'], 'Overall SLA%'), value: parseNumericCell(row[ headers.indexOf(overallHeader) ]), higherIsBetter: true},
      {label: 'TTR Hours(Official)', target: getTarget(['TTR Hours(Official)','TTR Hours (Official)','TTR'], 'TTR Hours(Official)'), value: parseNumericCell(row[ headers.indexOf(ttrHeader) ]), higherIsBetter: false},
      {label: '100% DA', target: getTarget(['100% DA','DA','100%DA'], '100% DA'), value: parseNumericCell(row[ headers.indexOf(daHeader) ]), higherIsBetter: true},
      {label: 'PPMD', target: getTarget(['PPMD'], 'PPMD'), value: parseNumericCell(row[ headers.indexOf(ppmdHeader) ]), higherIsBetter: false},
      {label: 'ECASE SLA_M2M', target: getTarget(['ECASE SLA_M2M','ECASE SLA M2M','ECASE M2M'], 'ECASE SLA_M2M'), value: parseNumericCell(row[ headers.indexOf(ecaseMHeader) ]), higherIsBetter: true},
      {label: 'ECASE SLA_HG', target: getTarget(['ECASE SLA_HG','ECASE SLA HG','ECASE HG'], 'ECASE SLA_HG'), value: parseNumericCell(row[ headers.indexOf(ecaseHHeader) ]), higherIsBetter: true},
      // You could add more metrics here if you want to count them
    ];

    // Count how many metrics are met
    let metCount = 0;
    let metricsConsidered = 0;
    targetsToCheck.forEach(m=>{
      const tgt = m.target;
      const val = m.value;
      if (tgt === null || tgt === undefined) {
        // skip metric if no target available
        return;
      }
      metricsConsidered++;
      if (val === null || val === undefined) {
        // not met if absent
        return;
      }
      if (m.higherIsBetter) {
        if (val >= tgt) metCount++;
      } else {
        if (val <= tgt) metCount++;
      }
    });

    // Score percent: percent of considered metrics met (scale to 0..100)
    const scorePercent = metricsConsidered > 0 ? (metCount / metricsConsidered) * 100 : 0;

    // Total closed volume for tie-break (parse numeric)
    const totalClosed = totalClosedHeader ? parseNumericCell(row[ headers.indexOf(totalClosedHeader) ]) : null;

    // accumulate
    if (!rowsByPeriod[periodVal]) rowsByPeriod[periodVal] = [];
    rowsByPeriod[periodVal].push({
      rowIndex: r+1,                           // actual sheet row index (1-based, header is row 1)
      empId: (row[ headers.indexOf(empIdHeader) ] || '').toString().trim(),
      name: nameHeader ? (row[ headers.indexOf(nameHeader) ] || '') : '',
      metCount,
      scorePercent,
      totalClosed: (totalClosed !== null && totalClosed !== undefined) ? Number(totalClosed) : -1
    });
  }

  // For each period, compute ranking and write back values to the sheet
  const outRangeWrites = []; // we'll collect [row, col, value] writes
  Object.keys(rowsByPeriod).forEach(period => {
    const list = rowsByPeriod[period];
    // sort by scorePercent desc, then totalClosed desc
    list.sort((a,b) => {
      if (b.scorePercent !== a.scorePercent) return b.scorePercent - a.scorePercent;
      return (b.totalClosed || 0) - (a.totalClosed || 0);
    });

    // assign dense ranks
    let rank = 0;
    let prevScore = null;
    list.forEach((entry, idx) => {
      if (prevScore === null || entry.scorePercent !== prevScore) {
        rank = idx + 1;
      }
      prevScore = entry.scorePercent;

      // prepare writes (find column indices)
      // TargetsMet write column index:
      const targetsMetColIdx = headers.indexOf('TargetsMet') + 1;
      const scorePercentColIdx = headers.indexOf('ScorePercent') + 1;
      const stackRankColIdx = headers.indexOf('StackRank') + 1;

      outRangeWrites.push({row: entry.rowIndex, col: targetsMetColIdx, value: entry.metCount});
      outRangeWrites.push({row: entry.rowIndex, col: scorePercentColIdx, value: Number(entry.scorePercent.toFixed(2))});
      outRangeWrites.push({row: entry.rowIndex, col: stackRankColIdx, value: rank});
    });
  });

  // Bulk write collected values to sheet
  // We'll group by row to minimize calls
  const writesByRow = {};
  outRangeWrites.forEach(w => {
    if (!writesByRow[w.row]) writesByRow[w.row] = {};
    writesByRow[w.row][w.col] = w.value;
  });

  const rowsToWrite = Object.keys(writesByRow).map(r => parseInt(r,10)).sort((a,b)=>a-b);
  rowsToWrite.forEach(rowNum => {
    const cols = Object.keys(writesByRow[rowNum]).map(c => parseInt(c,10));
    cols.forEach(colNum => {
      scoresSheet.getRange(rowNum, colNum).setValue(writesByRow[rowNum][colNum]);
    });
  });

  SpreadsheetApp.getUi().alert('Stack ranks computed and written into "scores". Columns updated: TargetsMet, ScorePercent, StackRank.');
}
