<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>HPE ScoreCard — All Metrics Included (Updated)</title>
<style>
  :root{--hpe-blue:#00739D;--muted:#5f6f76;--bg:#f4f7f8}
  body{font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);margin:0;color:var(--muted)}
  header{display:flex;justify-content:space-between;align-items:center;padding:18px;background:#fff;box-shadow:0 4px 16px rgba(0,0,0,0.05)}
  .brand .title{font-weight:700;color:var(--hpe-blue);font-size:20px}
  .controls{display:flex;gap:10px;align-items:center}
  select,input{padding:8px;border-radius:8px;border:1px solid #dfeff3;background:white}
  button{padding:8px 10px;border-radius:8px;border:0;background:var(--hpe-blue);color:white;cursor:pointer}
  main{max-width:1100px;margin:20px auto;padding:0 18px}
  .card{background:#fff;border-radius:10px;padding:18px;box-shadow:0 10px 30px rgba(10,20,30,0.04)}
  .top-right{text-align:right}
  .engineer-name{font-weight:700;color:#0b3b4a}
  .engineer-id{font-size:13px;color:#6b7b86}
  .status{margin-top:8px;color:#0b6b5d}
  table{width:100%;border-collapse:collapse;margin-top:14px}
  thead th{background:var(--hpe-blue);color:#fff;padding:12px;text-align:left}
  td,th{padding:12px;border-bottom:1px solid #eef6f9}
  .col-param{width:55%}
  .col-target,.col-score{width:22%;text-align:right}
  .good{color:#0b7a3a;font-weight:700}
  .bad{color:#a12b2b;font-weight:700}
  .no-data{padding:12px;border-radius:8px;background:#fff6f6;border:1px solid #ffd6d6;color:#8b1a1a;margin-top:12px}
  .avg-note{margin-top:10px;font-size:13px;color:#4d6a6f}
  @media (max-width:800px){ .controls{flex-wrap:wrap} .col-param{width:60%} }
</style>
</head>
<body>
<header>
  <div class="brand">
    <div class="title">ScoreCard</div>
    <div class="subtitle">HPE — All metrics included for Stack Rank</div>
  </div>

  <div class="controls">
    <label>Month</label>
    <select id="monthSelect"></select>
    <label>Employee ID</label>
    <input id="empInput" placeholder="eg 60154741" />
    <button id="apply">Apply</button>
  </div>
</header>

<main>
  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:flex-start">
      <div>
        <div id="status" class="status">Loading...</div>
        <div id="excludedNote" class="avg-note" style="display:none;color:#a15b00;"></div>
      </div>
      <div class="top-right">
        <div id="engineerName" class="engineer-name">—</div>
        <div id="engineerId" class="engineer-id">ID: —</div>
        <div id="stackRank" class="engineer-id">Stack Rank: —</div>
      </div>
    </div>

    <div id="content">
      <table id="compareTable" aria-label="Parameters comparison">
        <thead>
          <tr><th class="col-param">Parameters</th><th class="col-target">Target</th><th class="col-score">Score</th></tr>
        </thead>
        <tbody></tbody>
      </table>

      <div id="missingTargets" style="display:none" class="no-data"></div>
      <div id="missingData" style="display:none" class="no-data"></div>
    </div>
  </div>
</main>

<script>
(async function(){
  /***** CONFIG *****/
  const SHEET_ID = "1D7If5Nf1i2_f3OvUCxySkrE_IWUy_YgSl95-hDPDinw";
  const URL_SCORES = `https://opensheet.elk.sh/${SHEET_ID}/scores`;
  const URL_TARGETS = `https://opensheet.elk.sh/${SHEET_ID}/targets`;

  // parameters considered for stack rank (must match column names in sheet)
  const PARAMETERS = [
    "Onsite Response Met%",
    "Overall SLA%",
    "TOTAL CLOSED VOLUME",
    "TTR Hours(Official)",
    "100% DA",
    "PPMD",
    "PPMC",
    "ECASE SLA_M2M",
    "ECASE SLA_HG"
  ];

  // fallback targets (used if targets sheet missing or no period row)
  const FALLBACK_TARGETS = {
    "Onsite Response Met%": 0.90,
    "Overall SLA%": 0.99,
    "TTR Hours(Official)": 30,
    "100% DA": 0.92,
    "PPMD": 1.13,
    "PPMC": 1.13,
    "ECASE SLA_M2M": 0.97,
    "ECASE SLA_HG": 0.95
  };

  // minimum number of metrics required to include engineer in ranking
  const MIN_VALID_METRICS = 3;
  /***** END CONFIG *****/

  const monthSelect = document.getElementById('monthSelect');
  const empInput = document.getElementById('empInput');
  const applyBtn = document.getElementById('apply');
  const statusEl = document.getElementById('status');
  const engineerNameEl = document.getElementById('engineerName');
  const engineerIdEl = document.getElementById('engineerId');
  const stackRankEl = document.getElementById('stackRank');
  const tbody = document.querySelector('#compareTable tbody');
  const missingTargetsEl = document.getElementById('missingTargets');
  const missingDataEl = document.getElementById('missingData');
  const excludedNoteEl = document.getElementById('excludedNote');

  const params = new URLSearchParams(window.location.search);
  let EMP_ID = (params.get('id') || '').trim();
  const URL_PERIOD = (params.get('period') || '').trim();
  if (EMP_ID) empInput.value = EMP_ID;

  function setStatus(msg, isError=false){
    statusEl.textContent = msg;
    statusEl.style.color = isError ? '#8b1a1a' : '#0b6b5d';
  }
  async function fetchJson(url){
    const r = await fetch(url, {cache:'no-store'});
    if (!r.ok) throw new Error('Failed to fetch ' + url + ' (' + r.status + ')');
    return r.json();
  }

  function normalize(rows){
    if (!rows || !rows.length) return [];
    const firstKeys = Object.keys(rows[0]||{}).map(k=>String(k).trim());
    const looksLikeTitle = firstKeys.length === 1 || firstKeys.every(k => /^[\d\W]+$/.test(k) || k.length < 4);
    if (looksLikeTitle && rows.length > 1) {
      const headers = Object.values(rows[1]).map(v => String(v||'').trim());
      const dataRows = rows.slice(2);
      if (headers.every(h => h)) {
        return dataRows.map(r => {
          const vals = Object.values(r);
          const obj = {};
          headers.forEach((h,i)=> obj[h] = vals[i] ?? '');
          return obj;
        });
      }
    }
    return rows;
  }
  function parseNumeric(v){
    if (v == null || v === '') return null;
    const s = String(v).trim();
    if (s === '-') return null;
    if (s.includes('%')) {
      const n = parseFloat(s.replace('%','').replace(/,/g,''));
      return isNaN(n) ? null : n/100;
    }
    const n = parseFloat(s.replace(/,/g,''));
    if (isNaN(n)) return null;
    if (n > 0 && n <= 1) return n;
    return n;
  }
  function formatDisplay(val){
    if (val == null) return '--';
    if (typeof val === 'number') {
      if (val <= 1) return (val*100).toFixed(2) + '%';
      return val.toFixed(2);
    }
    const n = parseNumeric(val);
    if (n == null) return String(val);
    if (n <= 1) return (n*100).toFixed(02) + '%';
    return n.toFixed(2);
  }

  function findKey(obj, names){
    const keys = Object.keys(obj||{});
    for (const n of names){
      const exact = keys.find(k => k.trim().toLowerCase() === n.trim().toLowerCase());
      if (exact) return exact;
    }
    for (const n of names){
      const re = new RegExp(n.replace(/[%()]/g,'\\$&'),'i');
      const found = keys.find(k => re.test(k));
      if (found) return found;
    }
    return null;
  }

  // treat ttr, ppmd, ppmc as lower-is-better
  function lowerIsBetter(metric){
    return /ttr|ppmd|ppmc/i.test(metric);
  }

  function meetsTarget(metric, scoreVal, targetVal){
    if (scoreVal == null || targetVal == null) return null;
    // Both parseNumeric style: if values are percentages like 0.95 or full numbers like 95, comparison logic still works
    return lowerIsBetter(metric) ? (scoreVal <= targetVal) : (scoreVal >= targetVal);
  }

  // compute average TOTAL CLOSED VOLUME for a period (used as fallback target)
  function computeAverageTotalClosed(rowsForPeriod) {
    const key = rowsForPeriod.length ? findKey(rowsForPeriod[0], ['TOTAL CLOSED VOLUME','Total Closed Volume','TotalClosedVolume']) : null;
    if (!key) return null;
    let sum = 0, count = 0;
    rowsForPeriod.forEach(r => {
      const v = parseNumeric(r[key]);
      if (v != null) { sum += v; count++; }
    });
    return count ? (sum / count) : null;
  }

  // compute ranks across rows for the period using PARAMETERS and effective targets
  function computeRanks(rowsForPeriod, effectiveTargets) {
    // Build entries with counts of metrics considered and metrics met
    const entries = rowsForPeriod.map(r => {
      let met = 0, considered = 0;
      PARAMETERS.forEach(metric => {
        const k = findKey(r, [metric]);
        // Skip metric if no target (effectiveTargets may have null for some metrics)
        const tgtRaw = effectiveTargets[metric];
        if (tgtRaw === null || tgtRaw === undefined) return;
        const scoreRaw = k ? r[k] : null;
        const scoreNum = parseNumeric(scoreRaw);
        const tgtNum = parseNumeric(tgtRaw);
        if (scoreNum == null) return; // no score for this metric
        considered++;
        const ok = meetsTarget(metric, scoreNum, tgtNum);
        if (ok === true) met++;
      });

      // capture total closed (for tie-break), use numeric fallback 0
      const totalClosedKey = findKey(r, ['TOTAL CLOSED VOLUME','Total Closed Volume','TOTAL CLOSED VOLUME']);
      const totalClosed = totalClosedKey ? (parseNumeric(r[totalClosedKey]) || 0) : 0;

      const idKey = findKey(r, ['Employee ID','EmpID','EmployeeID','ID']);
      const empIdVal = idKey ? String(r[idKey]||'').trim() : '';

      return { row: r, empId: empIdVal, met, considered, scorePercent: considered ? (met / considered) * 100 : 0, totalClosed };
    });

    // Filter: only include entries with at least MIN_VALID_METRICS considered
    const included = entries.filter(e => e.considered >= MIN_VALID_METRICS);
    const excludedCount = entries.length - included.length;

    // Sort included by scorePercent desc then totalClosed desc
    included.sort((a,b) => {
      if (b.scorePercent !== a.scorePercent) return b.scorePercent - a.scorePercent;
      return b.totalClosed - a.totalClosed;
    });

    // assign ranks (ordinal-with-ties: equal scorePercent -> same rank, next index i+1)
    let prevScore = null;
    let rank = 0;
    included.forEach((e,i) => {
      if (prevScore === null || e.scorePercent !== prevScore) rank = i + 1;
      e.rank = rank;
      prevScore = e.scorePercent;
    });

    // Map ranks back into full list (excluded ones have rank = null)
    const all = entries.map(e => {
      const found = included.find(x => x.empId === e.empId && x.totalClosed === e.totalClosed && x.considered === e.considered && x.met === e.met);
      return { ...e, rank: found ? found.rank : null };
    });

    return { all, includedCount: included.length, excludedCount };
  }

  async function loadAll(){
    setStatus('Loading scores & targets...');
    missingTargetsEl.style.display = 'none';
    missingDataEl.style.display = 'none';
    try {
      const [rawScores, rawTargets] = await Promise.all([
        fetchJson(URL_SCORES).catch(()=>[]),
        fetchJson(URL_TARGETS).catch(()=>[])
      ]);
      const scores = normalize(rawScores || []);
      const targets = normalize(rawTargets || []);
      if (!scores.length) {
        setStatus('No data found in scores sheet', true);
        missingDataEl.style.display = 'block';
        missingDataEl.innerHTML = '<div class="no-data">No rows in scores sheet. Ensure the tab is named <strong>scores</strong> and published.</div>';
        return {scores:[], targets:[]};
      }
      setStatus(`Loaded ${scores.length} score rows`);
      return {scores, targets};
    } catch (err) {
      setStatus('Error loading sheets: ' + err.message, true);
      throw err;
    }
  }

  async function showForEmployee(allScores, allTargets, empId, period){
    setStatus('Preparing view...');
    tbody.innerHTML = '';
    missingTargetsEl.style.display = 'none';
    missingDataEl.style.display = 'none';
    excludedNoteEl.style.display = 'none';
    engineerNameEl.textContent = '—';
    engineerIdEl.textContent = 'ID: —';
    stackRankEl.textContent = 'Stack Rank: —';

    // filter rows for the requested period
    const rowsForPeriod = allScores.filter(r => {
      const pkey = findKey(r, ['Period','period']);
      return pkey && String(r[pkey]||'').trim() === String(period).trim();
    });

    if (!rowsForPeriod.length) {
      setStatus(`No data found for period ${period}`, true);
      missingDataEl.style.display = 'block';
      missingDataEl.innerHTML = `<div class="no-data">No rows found for period <strong>${period}</strong>.</div>`;
      return;
    }

    // find the employee row
    const empRow = rowsForPeriod.find(r => {
      const idKey = findKey(r, ['Employee ID','EmpID','EmployeeID','ID']);
      return idKey && String(r[idKey]||'').trim() === String(empId).trim();
    });

    if (!empRow) {
      setStatus(`No data found for Employee ${empId} in ${period}`, true);
      missingDataEl.style.display = 'block';
      missingDataEl.innerHTML = `<div class="no-data">No row found for employee <strong>${empId}</strong> in <strong>${period}</strong>.</div>`;
      return;
    }

    // locate target rows: per-emp then period
    let targetRowForPeriodAndEmp = null;
    if (allTargets && allTargets.length) {
      targetRowForPeriodAndEmp = allTargets.find(r => {
        const pKey = findKey(r, ['Period','period']);
        if (!pKey) return false;
        const pVal = String(r[pKey]||'').trim();
        if (pVal !== String(period).trim()) return false;
        const tEmpKey = findKey(r, ['Employee ID','EmpID','EmployeeID','ID']);
        if (tEmpKey) return String(r[tEmpKey]||'').trim() === String(empId).trim();
        return false;
      });
    }

    let targetRowForPeriod = null;
    if (allTargets && allTargets.length) {
      targetRowForPeriod = allTargets.find(r => {
        const pKey = findKey(r, ['Period','period']);
        return pKey && String(r[pKey]||'').trim() === String(period).trim();
      });
    }

    // compute avg total closed for period fallback
    const avgTotalClosed = computeAverageTotalClosed(rowsForPeriod);

    // build effectiveTargets (per-emp -> period -> average for total closed -> fallback)
    const effectiveTargets = {};
    PARAMETERS.forEach(metric => {
      if (targetRowForPeriodAndEmp) {
        const k = findKey(targetRowForPeriodAndEmp, [metric, metric.replace(/ /g,''), metric.replace(/_/g,' ')]);
        if (k) { effectiveTargets[metric] = targetRowForPeriodAndEmp[k]; return; }
      }
      if (targetRowForPeriod) {
        const k = findKey(targetRowForPeriod, [metric, metric.replace(/ /g,''), metric.replace(/_/g,' ')]);
        if (k) { effectiveTargets[metric] = targetRowForPeriod[k]; return; }
      }
      if (metric === 'TOTAL CLOSED VOLUME') {
        effectiveTargets[metric] = (avgTotalClosed != null) ? avgTotalClosed : null;
        return;
      }
      if (FALLBACK_TARGETS[metric] !== undefined) { effectiveTargets[metric] = FALLBACK_TARGETS[metric]; return; }
      effectiveTargets[metric] = null;
    });

    if (!allTargets.length) {
      missingTargetsEl.style.display = 'block';
      missingTargetsEl.innerHTML = `<div class="no-data">No <strong>targets</strong> sheet found or it's empty — using fallback targets and computed average for TOTAL CLOSED VOLUME where available.</div>`;
    } else if (!targetRowForPeriod && !targetRowForPeriodAndEmp) {
      missingTargetsEl.style.display = 'block';
      missingTargetsEl.innerHTML = `<div class="no-data">No target row found for <strong>${period}</strong> in the targets sheet; using fallback targets and computed average for TOTAL CLOSED VOLUME where available.</div>`;
    }

    // compute ranks
    const { all: rankingAll, includedCount, excludedCount } = computeRanks(rowsForPeriod, effectiveTargets);

    // find the entry for this employee
    const myEntry = rankingAll.find(e => {
      const idKey = findKey(e.row, ['Employee ID','EmpID','EmployeeID','ID']);
      return idKey && String(e.row[idKey]||'').trim() === String(empId).trim();
    });

    // show rank or excluded message
    if (myEntry && myEntry.rank != null) {
      stackRankEl.textContent = 'Stack Rank: ' + myEntry.rank;
      excludedNoteEl.style.display = 'none';
    } else {
      stackRankEl.textContent = 'Stack Rank: —';
      // tell user why excluded
      excludedNoteEl.style.display = 'block';
      excludedNoteEl.textContent = `This employee was excluded from ranking because fewer than ${MIN_VALID_METRICS} metrics (with targets) are available for this period.`;
    }

    // header details
    const nameKey = findKey(empRow, ['Engineer Name','Name','Engineer']);
    const idKey = findKey(empRow, ['Employee ID','EmpID','EmployeeID','ID']);
    engineerNameEl.textContent = nameKey ? (empRow[nameKey] || '—') : '—';
    engineerIdEl.textContent = 'ID: ' + (idKey ? (empRow[idKey] || '—') : empId);

    // populate table rows
    tbody.innerHTML = '';
    PARAMETERS.forEach(metric => {
      const targetRaw = effectiveTargets[metric];
      const targetNum = (targetRaw !== undefined && targetRaw !== null) ? parseNumeric(targetRaw) : null;
      const scoreKey = findKey(empRow, [metric, metric.replace(/ /g,''), metric.replace(/_/g,' ')]);
      const scoreRaw = scoreKey ? empRow[scoreKey] : null;
      const scoreNum = parseNumeric(scoreRaw);
      const met = (targetNum != null && scoreNum != null) ? meetsTarget(metric, scoreNum, targetNum) : null;
      const scoreClass = met === null ? '' : (met ? 'good' : 'bad');

      const targetDisplay = (targetNum != null) ? formatDisplay(targetNum) : '--';
      const scoreDisplay = (scoreNum != null) ? formatDisplay(scoreNum) : (scoreRaw ? String(scoreRaw) : '--');

      const tr = document.createElement('tr');
      tr.innerHTML = `<td class="col-param">${metric}</td>
                      <td class="col-target">${targetDisplay}</td>
                      <td class="col-score"><span class="${scoreClass}">${scoreDisplay}</span></td>`;
      tbody.appendChild(tr);
    });

    // show avg note if used for total closed volume
    const prevNote = document.querySelector('.avg-note');
    if (prevNote) prevNote.remove();
    if (avgTotalClosed != null) {
      const note = document.createElement('div');
      note.className = 'avg-note';
      note.textContent = `TOTAL CLOSED VOLUME target for ${period} = average across engineers = ${formatDisplay(avgTotalClosed)} (used if no explicit target provided).`;
      document.getElementById('content').appendChild(note);
    }

    setStatus(`Showing ${engineerNameEl.textContent} — ${period} (Ranked: ${includedCount}, Excluded: ${excludedCount})`);
  }

  async function boot(){
    try {
      const {scores, targets} = await (async ()=>{
        try {
          const [s,t] = await Promise.all([fetchJson(URL_SCORES), fetchJson(URL_TARGETS)]);
          return {scores: normalize(s||[]), targets: normalize(t||[])};
        } catch(e) {
          const s = await fetchJson(URL_SCORES);
          return {scores: normalize(s||[]), targets: []};
        }
      })();

      // populate months
      const periodSet = new Set();
      scores.forEach(r => {
        const pk = findKey(r, ['Period','period']);
        if (pk) { const v = String(r[pk]||'').trim(); if (v) periodSet.add(v); }
      });
      const periods = Array.from(periodSet).sort().reverse();
      monthSelect.innerHTML = '';
      monthSelect.appendChild(new Option('Latest',''));
      periods.forEach(p => {
        const [y,m] = p.split('-');
        let label = p;
        if (y && m && m.length) {
          try { label = new Date(`${y}-${m}-01`).toLocaleString('default',{month:'long'}) + ' ' + y; } catch(e){}
        }
        monthSelect.appendChild(new Option(label,p));
      });

      if (URL_PERIOD) monthSelect.value = URL_PERIOD;
      if (!monthSelect.value && periods.length) monthSelect.value = periods[0];

      applyBtn.onclick = () => {
        const emp = empInput.value.trim();
        const per = monthSelect.value;
        if (!emp) return alert('Enter Employee ID');
        if (!per) return alert('Select Month');
        const q = new URLSearchParams();
        q.set('id', emp); q.set('period', per);
        location.search = q.toString();
      };

      if (empInput.value.trim()) {
        await showForEmployee(scores, targets, empInput.value.trim(), monthSelect.value);
      } else {
        setStatus('Select month and enter Employee ID to view data.');
      }
    } catch (err) {
      setStatus('Error: ' + err.message, true);
      console.error(err);
    }
  }

  await boot();
})();
</script>
</body>
</html>
